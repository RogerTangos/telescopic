// Generated by CoffeeScript 1.6.3
var isEmpty, makeYAndZ;

test('.markup is linked with children like any other vertex', function() {
  var graph1;
  makeYAndZ();
  graph1 = makeTestVerticies().setGraphChildReferences();
  equal(markupZ.getChildren()[0][0], vertexH, "children of markupZ reference correctly");
  return equal(markupY.getChildren()[0][0], vertexO);
});

test('.markup has desired attributes', function() {
  var graph1;
  makeYAndZ();
  graph1 = makeTestVerticies().makeLinkedList(vertexA);
  equal(markupZ.getStarter(), false);
  equal(markupY.getStarter(), true);
  equal(markupZ.getName(), 'Z');
  equal(markupY.getName(), 'Y');
  equal(markupZ.getGraph(), graph1, 'getGraph() gives graph1');
  equal(markupY.getGraph(), graph1);
  equal(markupZ._next, null, 'next is null');
  equal(markupY._next, null);
  equal(markupZ._previous, null, 'previous is null');
  equal(markupY._previous, null);
  equal(markupZ.getClickCount(), 0, "click count is 0 when initialized");
  equal(markupY.getClickCount(), 0);
  equal(markupZ.getChildren()[0][0], 'H', "children of markupZ correct");
  equal(markupY.getChildren()[0][0], 'O');
  equal(markupZ.getRemainAfterClick(), true);
  equal(markupY.getRemainAfterClick(), true);
  equal(markupZ.incomingTree[0], false);
  equal(markupY.incomingTree[0], false);
  equal(markupZ.incomingForward[0], void 0);
  equal(markupY.incomingForward[0], void 0);
  equal(markupZ.incomingBack[0], void 0);
  equal(markupY.incomingBack[0], void 0);
  equal(markupZ.incomingCross[0], void 0);
  return equal(markupY.incomingCross[0], void 0);
});

test('.markup has no forwardClick or reverseClick', function() {
  makeYAndZ();
  makeTestVerticies().setGraphChildReferences().makeLinkedList(vertexA);
  equal(markupY.forwardClick, void 0, 'forward click is undefined');
  equal(markupZ.forwardClick, void 0);
  equal(markupY.reverseClick, void 0, 'reverse click is undefined');
  return equal(markupZ.reverseClick, void 0);
});

test('.markup .getWraps() initializes objects based on next. objects.', function() {
  makeYAndZ();
  makeTestVerticies().setGraphChildReferences().makeLinkedList(vertexA);
  ok(isEmpty(markupZ.getWraps), 'markups created w. empty spec._wraps and getWraps()');
  return ok(isEmpty(markupY.getWraps));
});

test('.markup determineWraps returns key-value lists based on the incoming vertex', function() {
  makeYAndZ();
  makeTestVerticies().setGraphChildReferences().makeLinkedList(vertexA);
  markupY.receiveForwardClick(vertexP);
  markupY.receiveForwardClick(vertexR);
  equal(markupY.getWraps()[vertexP][0][0], vertexO);
  equal(markupY.getWraps()[vertexR][0][0], vertexK);
  equal(markupY.getWraps()[vertexR][0][1], vertexL);
  return equal(markupY.getWraps()[vertexR][1][0], vertexP);
});

makeYAndZ = function() {
  telescopicText.reset();
  window.markupY = telescopicText.markup({
    _name: 'Y',
    content: '<em></em>',
    _children: [['O'], ['L', 'K']],
    _graph: 'graph1',
    _starter: true
  });
  return window.markupZ = telescopicText.markup({
    _name: 'Z',
    content: '<p><div></div></p>',
    _children: [['H'], ['Q', 'S', 'T']],
    _graph: 'graph1',
    _starter: false
  });
};

isEmpty = function(obj) {
  var key;
  for (key in obj) {
    if (obj.hasOwnProperty(key)) {
      return false;
    }
  }
  return true;
};
