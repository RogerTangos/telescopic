// Generated by CoffeeScript 1.6.3
telescopicText.markup = function(spec) {
  var that;
  that = telescopicText.vertex(spec);
  that.isMarkup = true;
  spec._wraps = {};
  spec._wrapLevel = {};
  /* overridden*/

  that.getRemainAfterClick = function() {
    return true;
  };
  that.getWrapLevel = function(key) {
    return spec._wrapLevel[key];
  };
  /* remove unnecessary functions*/

  delete that.setDomVisibility;
  delete that.forwardClick;
  delete that.reverseClick;
  delete that.userClick;
  /* public methods*/

  that.getWraps = function() {
    return spec._wraps;
  };
  that.pushToIncomingTree = function(incomingVertex) {
    if (that.incomingTree[0] === false) {
      that.incomingTree[0] = incomingVertex;
    } else {
      that.incomingTree.push(incomingVertex);
    }
    return that;
  };
  that.createStartListForChildren = function(childSetIndex) {
    var child, nodeDict, previous, set, _i, _j, _len, _len1;
    set = spec._children[childSetIndex];
    nodeDict = {};
    for (_i = 0, _len = set.length; _i < _len; _i++) {
      child = set[_i];
      nodeDict[child.getName()] = true;
    }
    for (_j = 0, _len1 = set.length; _j < _len1; _j++) {
      child = set[_j];
      previous = nodeDict[child.getPrevious().getName()];
      if (previous !== void 0) {
        nodeDict[child.getName()] = false;
      }
    }
    return nodeDict;
  };
  that.setWrapLevel = function(incomingVertex) {
    var current, htmlArray, isHtmlString, _results;
    isHtmlString = /^\<.+\>/.test(that.content);
    if (isHtmlString) {
      spec._wrapLevel[incomingVertex] = 1;
      /* convert to html using jquery*/

      htmlArray = $(that.content);
      current = htmlArray.children();
      _results = [];
      while (current[0]) {
        spec._wrapLevel[incomingVertex] += 1;
        _results.push(current = current.children());
      }
      return _results;
    } else {
      return spec._wrapLevel[incomingVertex] = $(that.content).length;
    }
  };
  that;
  /* forward clicks*/

  that.receiveForwardClick = function(incomingVertex) {
    var key, linkArray, next, nextName, nodeDict, value, wrapArray;
    that.setWrapLevel(incomingVertex);
    /* create arrays of linked lists. push them to
    			wrapArray. Weird stuff with key not giving objects
    			correctly. Hence, the .getName() shuffle
    */

    spec._wraps[incomingVertex] = [];
    wrapArray = spec._wraps[incomingVertex];
    nodeDict = this.createStartListForChildren(spec._clickCount);
    for (key in nodeDict) {
      value = nodeDict[key];
      if (value === true) {
        linkArray = [spec._graph.getNode(key)];
        next = spec._graph.getNode(key).getNext();
        if (next) {
          nextName = next.getName();
        }
        while (nodeDict[nextName] === false) {
          linkArray.push(spec._graph.getNode(next));
          next = next.getNext();
          if (next) {
            nextName = next.getName();
          } else {
            nextName = false;
          }
        }
        wrapArray.push(linkArray);
      }
    }
    spec._clickCount += 1;
    that.wrap(incomingVertex);
    that.pushToIncomingTree(incomingVertex);
    return that;
  };
  /* reverse clicking utilities*/

  that.receiveReverseClickFromParent = function(parentVertex) {
    that.unwrap(parentVertex);
    /* reset defaults*/

    delete spec._wraps[parentVertex];
    delete spec._wrapLevel[parentVertex];
    that.setEdgesToDefault();
    spec._clickCount += -1;
    return that;
  };
  that;
  /* DOM manipulation*/

  that.wrap = function(incomingVertex) {
    var selector, set, vertex, vertexArray, verticies, _i, _j, _len, _len1;
    verticies = spec._wraps[incomingVertex];
    for (_i = 0, _len = verticies.length; _i < _len; _i++) {
      set = verticies[_i];
      vertexArray = [];
      for (_j = 0, _len1 = set.length; _j < _len1; _j++) {
        vertex = set[_j];
        vertexArray.push(vertex.getName());
      }
      selector = '#tText_' + vertexArray.join(', #tText_');
      $(selector).wrapAll(that.content);
    }
    return that;
  };
  that.unwrap = function(incomingVertex) {
    var i, selector, set, vertex, vertexArray, verticies, _i, _j, _len, _len1;
    verticies = spec._wraps[incomingVertex];
    for (_i = 0, _len = verticies.length; _i < _len; _i++) {
      set = verticies[_i];
      vertexArray = [];
      for (_j = 0, _len1 = set.length; _j < _len1; _j++) {
        vertex = set[_j];
        vertexArray.push(vertex.getName());
      }
      selector = '#tText_' + vertexArray.join(', #tText_');
      i = 0;
      while (i < spec._wrapLevel[incomingVertex]) {
        $(selector).unwrap();
        i++;
      }
    }
    return that;
  };
  return that;
};

telescopicText.markup.prototype.toString = function() {
  return "[object telescopicText.markup]";
};
