// Generated by CoffeeScript 1.6.3
/* add all private attributes to spec by convention.*/

var telescopicText;

telescopicText = {};

telescopicText.graphs = {};

telescopicText.reset = function() {
  return telescopicText.graph({
    _name: 'telescopicDefaultID'
  });
};

telescopicText.graph = function(spec) {
  /* set defaults*/

  var that, _nodes;
  spec = spec || {};
  spec._name = spec._name || 'telescopicDefaultID';
  /* private attributes*/

  that = {};
  _nodes = {};
  /* constructor. default text, and insert into graphs*/

  telescopicText.graphs[spec._name] = that;
  /* public functions*/

  that.getName = function() {
    return spec._name;
  };
  that.getNode = function(keyOrVertex) {
    /* in case get the vertex's key*/

    var node;
    if (keyOrVertex instanceof Object) {
      keyOrVertex = keyOrVertex.getName();
    }
    node = _nodes[keyOrVertex];
    if (node === void 0) {
      console.log('Graph "' + this.getName() + '" is missing a child, with key "' + keyOrVertex + '."');
      void 0;
    }
    return node;
  };
  that.setNode = function(key, value) {
    _nodes[key] = value;
    return that;
  };
  that.makeLinkedList = function(startVertex) {
    var currentVertex, nextVertex, _results;
    startVertex = that.getNode(startVertex);
    currentVertex = startVertex;
    nextVertex = that.getNode(currentVertex.getNext());
    if (!startVertex.getNext()) {
      console.log('Careful! This graph only has one vertex linked.');
      +'and that seems pretty silly to me.';
    }
    _results = [];
    while (nextVertex) {
      if (nextVertex === startVertex) {
        currentVertex.setNext(null);
        nextVertex.setPrevious(null);
        console.log("Your linked list is cyclical when it should be linear. " + "Did not link the start and end nodes.");
        _results.push(nextVertex = false);
      } else {
        telescopicText.graph.link(currentVertex, nextVertex);
        currentVertex = nextVertex;
        _results.push(nextVertex = that.getNode(currentVertex.getNext()));
      }
    }
    return _results;
  };
  /* linking/children functions*/

  that.setReferencesForChildrenThroughoutGraph = function() {
    var key, value, _results;
    _results = [];
    for (key in _nodes) {
      value = _nodes[key];
      _results.push(value.setChildrenReferences());
    }
    return _results;
  };
  return that;
};

/* object level functions*/


telescopicText.graph.link = function(fromVertex, toVertex) {
  fromVertex.setNext(toVertex);
  return toVertex.setPrevious(fromVertex);
};

telescopicText.graph.dangerousUnlink = function(vertex) {
  var next, previous;
  next = vertex.getNext();
  previous = vertex.getPrevious();
  vertex.setNext(null);
  vertex.setPrevious(null);
  if (next) {
    next.setPrevious(null);
  }
  if (previous) {
    return previous.setNext(null);
  }
};

telescopicText.graph.safeUnlink = function(vertex) {
  var next, previous;
  next = vertex.getNext();
  previous = vertex.getPrevious();
  vertex.setNext(null);
  vertex.setPrevious(null);
  if (next) {
    next.setPrevious(previous);
  }
  if (previous) {
    return previous.setNext(next);
  }
};

telescopicText.vertex = function(spec) {
  /* set defaults*/

  var that;
  spec = spec || {};
  spec._starter = spec._starter || false;
  spec._children = spec._children || [];
  spec._remainAfterClick = spec._remainAfterClick || false;
  spec._next = spec._next || null;
  /* constructor*/

  if (!telescopicText.graphs[spec._graph]) {
    spec._graph = telescopicText.graph({
      _name: spec._graph
    });
  } else {
    spec._graph = telescopicText.graphs[spec._graph];
  }
  /* private attributes*/

  that = {};
  spec._previous = null;
  spec._clickCount = 0;
  /* public attributes*/

  that.content = spec.content;
  that.incomingTree = false;
  that.incomingForward = [];
  that.incomingBack = [];
  that.incomingCross = [];
  /* public functions*/

  that.getStarter = function() {
    return spec._starter;
  };
  that.getName = function() {
    return spec._name;
  };
  that.getGraph = function() {
    return spec._graph;
  };
  that.getNext = function() {
    return spec._next;
  };
  that.setNext = function(newNext) {
    return spec._next = newNext;
  };
  that.getPrevious = function() {
    return spec._previous;
  };
  that.setPrevious = function(newPrevious) {
    return spec._previous = newPrevious;
  };
  that.getClickCount = function() {
    return spec._clickCount;
  };
  that.getChildren = function() {
    return spec._children;
  };
  that.getRemainAfterClick = function() {
    return spec._remainAfterClick;
  };
  /* public functions meta info*/

  that.findClicksRemaining = function() {
    /* ignore _remainAfterClick b/c it's not a click*/

    return spec._children.length - spec._clickCount;
  };
  that.shouldBeVisible = function() {
    if (that.getStarter() && that.findClicksRemaining() > 0) {
      return true;
    } else if (that.getStarter() && that.getRemainAfterClick()) {
      return true;
      /* not a starter node*/

    } else if (that.findClicksRemaining() > 0 && that.incoming_tree) {
      return true;
    } else if (that.incoming_tree && that.getRemainAfterClick()) {
      return true;
    } else {
      return false;
    }
  };
  /* linking utilities*/

  that.setChildrenReferences = function() {
    var child, childIndex, childKey, setIndex;
    setIndex = 0;
    while (setIndex < spec._children.length) {
      childIndex = 0;
      while (childIndex < spec._children[setIndex].length) {
        childKey = spec._children[setIndex][childIndex];
        child = spec._graph.getNode(childKey);
        if (child === void 0) {
          console.log('The key, "' + childKey + '", will be removed from vertex\'s child array.');
          spec._children[setIndex].splice(childIndex, 1);
        } else {
          spec._children[setIndex][childIndex] = child;
          childIndex += 1;
        }
      }
      setIndex += 1;
    }
    return that;
  };
  /* clicking utilities*/

  that.forwardClick = function() {
    /* catch instance in which it shouldn't be clicked*/

    spec._clickCount += 1;
    return this;
  };
  this.receiveForwardClick = function(incoming_vertex) {
    this.forwardDetermineAndSetIncomingEdge(incoming_vertex);
    return this;
  };
  this.reverseClick = function() {
    if (!this.shouldBeReverseClickable()) {
      return this;
    }
    this.incoming_tree.receiveReverseClickFromChild(this);
    return this;
  };
  this.receiveReverseClickFromChild = function(child_vertex) {
    var child, child_index, _i, _len, _ref;
    _clickCount += -1;
    child_index = this.findIndexOfChildInChildren(child_vertex);
    _ref = this.children[child_index];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      child.receiveReverseClickFromParent(this);
    }
    return this;
  };
  this.receiveReverseClickFromParent = function(parent_vertex) {
    if (this.incoming_tree === parent_vertex) {
      this.setEdgesToDefault();
    }
    return this;
  };
  this.setChildrenReferences = function() {
    var child, child_index, child_key, set_index, _results;
    set_index = 0;
    _results = [];
    while (set_index < this.children.length) {
      child_index = 0;
      while (child_index < this.children[set_index].length) {
        child_key = this.children[set_index][child_index];
        child = _graph.returnVertexFromKeyOrObject(child_key);
        if (!(child instanceof telescopicText.Vertex)) {
          console.log('The key, "' + child_key + '", will be removed from vertex\'s child array.');
          this.children[set_index].splice(child_index, 1);
        } else {
          this.children[set_index][child_index] = child;
          child_index += 1;
        }
      }
      _results.push(set_index += 1);
    }
    return _results;
  };
  /* insert node into graph*/

  spec._graph.setNode(spec._name, that);
  return that;
};
